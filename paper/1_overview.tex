% В обзорном разделе проводится исследование предметной области, с которой связан данный курсовой
% проект, рассматриваются основные существующие алгоритмы и технологии, позволяющие решить
% поставленную в рамках курсового проектирования задачу. Объём обзорного раздела должен составлять
% около 10 листов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TEXT WIDTH %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Обзор СУБД Dgraph}

В разделе описываются основные особенности СУБД Dgraph и её средства для загрузки данных и выполнения
запросов. Основная часть информации в разделе взята из официальной документации Dgraph версии
23.1~\cite{dgraphDocs}.

\subsection{Графовая модель данных}

Dgraph является нативной графовой СУБД, то есть графовая модель данных в ней ---
единственная\footnote{Существуют мультимодельные СУБД. Например, в ArangoDB помимо графовой
поддерживаются документо-ориентированная модель и модель <<ключ-значение>>.}. Современные графовые
СУБД поддерживают, как правило, одну из двух следующих реализаций графовой модели:
\begin{itemize}
    \item \textit{граф свойств} (property graph), хранящий вершины (сущности), рёбра (связи между
сущностями) и свойства, описывающие вершины или рёбра. Dgraph поддерживает именно эту модель;
    \item \textit{RDF-граф}, использующий модель субъект-предикат-объект для хранения информации.
Dgraph поддерживает формат RDF для импорта и экспорта данных --- это подробно описано в следующих
разделах.
\end{itemize}

Связи между сущностями в Dgraph направленные, что позволяет оптимально совершать обход от одной
сущности к другой. Для двунаправленной связи нужно, что естественно, установить связь между
сущностями в обе стороны.

\subsection{Архитектура}

Dgraph эффективно масштабируется для работы с большими объёмами данных, поскольку проектируется с
самого начала для распределённого использования. В основе его работы --- кластер взаимодействующих
друг с другом серверных узлов, образующих единое логическое хранилище данных. В Dgraph выделяются
два типа серверных узлов:
\begin{itemize}
    \item \textit{Zero-узлы} содержат метаданные кластера Dgraph, координируют распределённые
транзакции и балансируют данные между группами серверов;
    \item \textit{Alpha-узлы} хранят данные графа и индексы. Важно отметить, что Alpha-узлы хранят
и индексируют \textit{предикаты}\footnote{Предикаты определяются в разделе \ref{dqlSchema}},
представляющие связи между данными. Такой подход позволяет Dgraph выполнять запросы глубины $N$ к
базе данных ровно за $N$ сетевых переходов.
\end{itemize}
Каждый кластер Dgraph должен иметь как минимум один Zero- и один Alpha-узел.

\subsection{Поддержка GraphQL}

В Dgraph встроена поддержка технологии GraphQL~\cite{graphql}. GraphQL --- язык запросов и
манипулирования данными для API, а также серверная среда выполнения запросов с открытым исходным
кодом. GraphQL позволяет клиенту в декларативной форме описывать точные данные, требуемые от API.
Вместо нескольких конечных точек (endpoints), возвращающих раздельные данные, сервер GraphQL
предоставляет единственнную, возвращающую ровно ту информацию, которую запрашивает клиент. Сервер
GraphQL может извлекать данные из различных источников, представляя результат в виде единого графа,
то есть GraphQL не привязан к какой-либо базе данных или иному механизму хранения информации.

Для запуска сервиса GraphQL необходимо определить \textit{схему} --- типы данных и их поля, и для
каждого такого поля --- его \textit{разрешающую функцию} (resolver), вычисляющую значение поля.
Принимая запрос, GraphQL его валидидирует соответственно определённой схеме, и в случае успеха
выполняет, вызывая соответствующие полям запроса разрешающие функции. Сервер возвращает данные, в
точности отвечающие исходному запросу.

Нативная поддержка GraphQL выделяет Dgraph на фоне его аналогов. Пользователю достаточно описать
схему GraphQL, и GraphQL API будет готов к работе. Dgraph автоматически определит разрешающие
функции: в основе их реализации --- простое следование по связям в графе от вершины к вершине и от
вершины к полю, что и обеспечивает нативную графовую производительность.

\subsection{Поддержка DQL}

На практике часто возникает необходимость в выполнении сложных запросов, не поддерживаемых
спецификацией GraphQL. Для этого разработан Dgraph Query Language (DQL) --- проприетарный язык
запросов Dgraph, синтаксически напоминающий GraphQL, но обладающий большей выразительной силой.
Кажется, что при наличии DQL нет необходимости в поддержке GraphQL. На деле же языки различаются
своим назначением~\cite{graphqlVsDql} и оба могут обоснованно использоваться в рамках одного
проекта.

Сервис GraphQL предоставляет API для контролируемого и защищённого доступа внешних клиентов к базе
данных. Dgraph поддерживает набор директив для применения в схеме GraphQL, посредством которых
выражаются правила авторизации доступа к данным и иные ограничения бизнес-логики.

DQL следует использовать как язык <<сырых>> запросов к базе данных, подобных, например, языку SQL. 
Предполагается, что Dgraph доверяет клиентам DQL. DQL позволяет выполнять продвинутые запросы к
базе даных и лучше подходит для работы с большими данными, допускающими пакетную обработку.

\subsection{Схема DQL} \label{dqlSchema}

Схема DQL содержит данные о типах \textit{предикатов}. Предикат --- это наименьший фрагмент
информации о сущности. Предикат может содержать литеральное значение или связь с другой сущностью.
Рассмотрим на примере:
\begin{itemize}
    \item пусть мы сохраняем имя сущности --- ''Петя''. Тогда мы можем использовать некоторый
предикат \texttt{name}, значением которого будет строка ''Петя'';
    \item пусть мы сохраняем отношение сущностей: Петя знает Машу. Тогда мы можем использовать
некоторый предикат \texttt{knows}, значением которого будет идентификатор сущности,
представляющей Машу.
\end{itemize}

Объявление предиката в схеме имеет вид
\begin{Verbatim}
предикат: тип_предиката директивы .
\end{Verbatim}
где \texttt{директивы} опциональны. Некоторые из поддерживаемых типов предикатов:
\begin{itemize}
    \item \texttt{int} --- целочисленный (32 бита);
    \item \texttt{float} --- вещественнозначный (64 бита);
    \item \texttt{string} --- строковый;
    \item \texttt{uid} --- численный универсальный идентификатор.
\end{itemize}
Предикат также может содержать список элементов --- для этого тип в объявлении обрамляется
квадратными скобками.

Посредством директив, в частности, определяются индексы на предикаты (директива \texttt{@index})
или обратные связи для \texttt{uid} (директива \texttt{@reversed}).

\subsection{DQL и графовые алгоритмы}

Хотя язык DQL подобен языку SQL по своей направленности, DQL ограничен в своей выразительности и
не пригоден для реализации графовых алгоритмов. Например, запрос с подсчётом всех треугольников в
графе не выразим на языке DQL.

DQL поддерживает альтернативу классическому обходу графа в ширину --- \textit{рекурсивный запрос}.
В запросе указываются глубина и предикаты схемы DQL, по которым совершается обход. В запросе
(не только рекурсивном) может быть указана директива \texttt{@ignorereflex}: она принудительно
удаляет дочерние узлы, которые достижимы из самих себя как родительские.

DQL также поддерживает поиск кратчайшего пути между двумя вершинами. В теле запроса указываются
предикаты, по которым совершается обход.

\subsection{Формат RDF}

В Dgraph встрена поддержка формата RDF при создании, импорте и экспорте данных. Resource Description
Framework (RDF)~\cite{rdf} --- семантический веб-стандарт обмена данными, посредством которого
выражаются утверждения о ресурсах. Утверждения описываются в форме троек, оканчивающихся точкой:
\begin{Verbatim}
<субъект> <предикат> <объект> .
\end{Verbatim}
Каждая тройка представляет некоторый факт о сущности.

В Dgraph \texttt{<субъект>} всегда является сущностью и представляется типом \texttt{uid},
\texttt{<объект>} может быть или другой сущностью, или литеральными значением, а
\texttt{<предикат>} определяет отношение между субъектом и объектом. Например,
\begin{Verbatim}
<0x01> <name> "Петя" .
<0x01> <knows> <0x02> .
\end{Verbatim}

При создании сущности могут быть ассоцированы с некоторыми временными именами, что позволит Dgraph
самостоятельно назначить им UID. Для этого имена предваряются строчкой <<\_:>>. Таким образом,
все упоминания одного и того же имени, например, \texttt{\_:Petya}, будут соответствовать одной и
той же сущности в рамках операции. Идентификаторы такого формата называются \textit{blank}-идентификаторами.

Dgraph работает с собственным расширением формата RDF, позволяющим назначать свойства не только
сущностям (субъектам), но и отношениям (предикатам). Свойства отношений или \textit{фасеты} (facets) описываются парами
ключ-значение, перечисляемыми в круглых скобках после указания объекта RDF. Например,
\begin{Verbatim}
_:Petya <car> "A123BC" (since=2020-01-01T12:00:00, first=true) .
\end{Verbatim}

Ключи фасетов должны быть уникальными. Все фасеты должны указываться в рамках одной тройки RDF
(иначе произойдёт перезапись). Допустимы следующие типы значений
свойств: \texttt{string}, \texttt{bool}, \texttt{int} (32 бита), \texttt{float} (64 бита) и
\texttt{dateTime}. Типы свойств не указываются явно, Dgraph их автоматически определяет по
формату значения.

\subsection{Формат JSON}

При вставке, обновлении данных или возврате структур также может использоваться формат JSON.
Вложенность в JSON-объектах выражает отношения между сущностями. Например,
\begin{Verbatim}
{"name": "Петя", "homeAddress": {"street": "ул. Пушкина"}}
\end{Verbatim}
интуитивно соответствует сущностями некоторых типов \texttt{Person}, \texttt{Address} и отношению
\texttt{homeAddress} между ними.

Данные в форматах RDF и JSON приводятся к единому внутреннему представлению Dgraph, поэтому их
использование одинаково эффективно. Однако RDF, в отличие от JSON, позволяет явно назначать
типы данных объектам, если это необходимо.

\subsection{Загрузка данных}

Для загрузки больших объёмов данных целесообразно использовать специализированные для импорта
инструменты Dgraph. Таких инструментов два: Live Loader и Bulk Loader.

Live Loader используется для загрузки данных в работающем экземпляре Dgraph, где уже может
содержаться некоторая информация. Исходные данные преобразуются загрузчиком в \textit{мутации}
Dgraph --- запросы на создание или изменение данных --- для дальнейшей отправки кластеру. Live Loader
позволяет управлять назначением UID добавляемым
сущностям, а также обновлять существующие данные. Перед использованием Live Loader необходимо
определить схему Dgraph, чтобы создать индексы на предикаты и уменьшить общее время загрузки.

Bulk Loader используется только для загрузки данных в новый кластер и не может быть
запущен в работающем экземпляре Dgraph. Bulk Loader работает значительно быстрее Live Loader,
и поэтому лучше подходит для импорта больших датасетов в новый кластер. При работе с Bulk Loader
должны быть запущено только Zero-узлы Dgraph; Alpha-узлы запускаются по завершении загрузки данных. 
При использовании Bulk Loader схема Dgraph может быть передана загрузчику прямо вместе в данными.

И Live Loader, и Bulk Loader принимают данные в формате JSON или в Dgraph-расширении формата RDF.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TEXT WIDTH %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
